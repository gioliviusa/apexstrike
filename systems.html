<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interstellar Explorer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            min-height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            color: #fff;
        }
        
        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .title {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
            font-size: 2rem;
            font-weight: 300;
            letter-spacing: 4px;
            z-index: 10;
            pointer-events: none;
            animation: fadeIn 3s ease-out;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
            text-align: center;
            letter-spacing: 1px;
            z-index: 10;
            pointer-events: none;
            animation: fadeIn 5s ease-out;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 16px;
            border-radius: 20px;
        }
        
        .celestial-label {
            position: absolute;
            color: rgba(255, 255, 255, 0.9);
            font-size: 1rem;
            pointer-events: none;
            z-index: 10;
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            transform: translate(-50%, -50%);
            font-weight: 400;
            letter-spacing: 1px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 10px;
            opacity: 0;
            transition: opacity 0.5s ease, transform 0.3s ease;
        }
        
        .celestial-label.visible {
            opacity: 1;
        }
        
        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 10px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .control-btn {
            background: rgba(50, 120, 200, 0.7);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }
        
        .control-btn:hover {
            background: rgba(70, 150, 250, 0.9);
            transform: translateY(-2px);
        }
        
        .orbit-path {
            position: absolute;
            border: 2px solid rgba(100, 180, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1;
            opacity: 1;
            transition: opacity 0.5s ease;
            box-shadow: 0 0 10px rgba(100, 180, 255, 0.3);
        }
        
        .black-hole-label {
            position: absolute;
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.2rem;
            pointer-events: none;
            z-index: 10;
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 15px;
            border-radius: 20px;
            border: 1px solid rgba(255, 100, 255, 0.3);
        }
        
        .black-hole-portal {
            position: absolute;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(255,0,255,0.8) 0%, rgba(0,0,0,0) 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            animation: pulse 2s infinite alternate;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.7; }
            100% { transform: scale(1.2); opacity: 1; }
        }
        
        @media (max-width: 768px) {
            .title {
                font-size: 1.5rem;
            }
            
            .control-panel {
                top: 10px;
                left: 10px;
                padding: 8px;
            }
        }
@media (max-width: 600px) {
    .back-home-link {
        top: 8px;
        left: 6px;
        font-size: 1rem;
        padding: 8px 14px;
        border-radius: 18px;
        box-shadow: 0 1px 4px rgba(0,0,0,0.18);
    }
    .title {
        font-size: 1.1rem;
        top: 48px;
    }
}
.back-home-link {
    position: absolute;
    top: 18px;
    left: 16px;
    z-index: 20;
    color: #fff;
    background: rgba(0,0,0,0.6);
    padding: 10px 20px;
    border-radius: 24px;
    text-decoration: none;
    font-size: 1.1rem;
    font-weight: 400;
    letter-spacing: 1px;
    transition: background 0.2s, color 0.2s;
    box-shadow: 0 2px 8px rgba(0,0,0,0.18);
    display: inline-block;
    line-height: 1.2;
    user-select: none;
}
.back-home-link:active, .back-home-link:focus {
    background: rgba(80,80,80,0.7);
    color: #ffe;
}
    </style>
    .back-home-btn {
        display: inline-block;
        margin-top: 12px;
        background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
        color: #fff;
        padding: 10px 24px;
        border-radius: 24px;
        text-decoration: none;
        font-size: 1.1rem;
        font-weight: 500;
        letter-spacing: 1px;
        transition: background 0.2s, color 0.2s, box-shadow 0.2s;
        box-shadow: 0 2px 8px rgba(0,0,0,0.18);
        border: none;
        cursor: pointer;
        text-align: center;
        user-select: none;
    }
    .back-home-btn:hover, .back-home-btn:focus {
        background: linear-gradient(90deg, #43e97b 0%, #38f9d7 100%);
        color: #222;
        box-shadow: 0 4px 16px rgba(0,0,0,0.22);
    }
    @media (max-width: 600px) {
        .back-home-btn {
            font-size: 1rem;
            padding: 8px 14px;
            border-radius: 18px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.18);
            margin-top: 8px;
        }
        .title {
            font-size: 1.1rem;
            top: 48px;
        }
    }
</style>
</head>
<body>
    <div class="title">INTERSTELLAR EXPLORER</div>
    <div class="instructions">Drag to rotate • Scroll to zoom • Click black hole to travel</div>
    <div class="control-panel">
        <button class="control-btn" id="reset-btn">Reset View</button>
        <button class="control-btn" id="zoom-out-btn">Zoom Out</button>
        <button class="control-btn" id="toggle-labels-btn">Toggle Labels</button>
        <button class="control-btn" id="toggle-orbits-btn">Toggle Orbits</button>
        <button class="control-btn" id="warp-btn">Warp to Black Hole</button>
        <a href="index.html" class="back-home-btn">← Back to Home</a>
    </div>
    
    <div id="scene-container"></div>
    <div id="labels-container"></div>
    <div id="orbits-container"></div>
    <div id="black-hole-portal" class="black-hole-portal" style="display: none;"></div>

    <script>
        // Constants
        const SOLAR_SYSTEM = 0;
        const ALIEN_SYSTEM = 1;
        const MILKY_WAY_SYSTEM = 2;
        
        // Global variables
        let currentSystem = SOLAR_SYSTEM;
        let labelsVisible = true;
        let orbitsVisible = true;
        let blackHole;
        
        // Set up Three.js scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000010);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('scene-container').appendChild(renderer.domElement);
        
        // Create containers
        const labelsContainer = document.getElementById('labels-container');
        const orbitsContainer = document.getElementById('orbits-container');
        const blackHolePortal = document.getElementById('black-hole-portal');
        
        // Initialize containers
        labelsContainer.style.position = 'fixed';
        labelsContainer.style.top = '0';
        labelsContainer.style.left = '0';
        labelsContainer.style.width = '100%';
        labelsContainer.style.height = '100%';
        labelsContainer.style.pointerEvents = 'none';
        
        orbitsContainer.style.position = 'fixed';
        orbitsContainer.style.top = '0';
        orbitsContainer.style.left = '0';
        orbitsContainer.style.width = '100%';
        orbitsContainer.style.height = '100%';
        orbitsContainer.style.pointerEvents = 'none';
        orbitsContainer.style.zIndex = '1';
        
        // Add orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 20;
        controls.maxDistance = 2000;
        
        // Position camera
        camera.position.set(0, 50, 150);
        controls.update();
        
        // Create stars background with twinkling effect
        function createStars() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            const sizes = [];
            
            for (let i = 0; i < 10000; i++) {
                vertices.push(
                    THREE.MathUtils.randFloatSpread(3000),
                    THREE.MathUtils.randFloatSpread(3000),
                    THREE.MathUtils.randFloatSpread(3000)
                );
                
                // Random star colors
                const colorType = Math.random();
                if (colorType < 0.1) {
                    colors.push(0.8, 0.8, 1.0); // Blue
                } else if (colorType < 0.2) {
                    colors.push(1.0, 0.9, 0.7); // Yellow
                } else if (colorType < 0.3) {
                    colors.push(1.0, 0.7, 0.7); // Red
                } else {
                    colors.push(1.0, 1.0, 1.0); // White
                }
                
                sizes.push(Math.random() < 0.1 ? 0.5 : 0.2);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                size: 0.2,
                sizeAttenuation: true,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
            
            return stars;
        }
        
        const stars = createStars();
        
        // Create celestial objects
        let sun;
        const planets = [];
        const orbitLines = [];
        // Comets
        const comets = [];

        // Initialize Milky Way system
        function initMilkyWaySystem() {
            // Clear previous objects
            scene.children = [];
            scene.add(stars);

            // Create Milky Way sun (blue-white giant)
            const sunGeometry = new THREE.SphereGeometry(13, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0x99ccff,
                emissive: 0x66aaff,
                emissiveIntensity: 3.5
            });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            scene.add(sun);

            // Sun light
            const sunLight = new THREE.PointLight(0x99ccff, 2.2, 1400);
            sunLight.position.copy(sun.position);
            scene.add(sunLight);

            // Sun glow
            const sunGlowGeometry = new THREE.SphereGeometry(16, 32, 32);
            const sunGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0x99ccff,
                transparent: true,
                opacity: 0.35,
                side: THREE.BackSide
            });
            const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
            sun.add(sunGlow);

            // Planet data for Milky Way system
            const planetsData = [
                { name: 'GAIA', radius: 7, distance: 70, color: 0x7fffd4, speed: 0.021 },
                { name: 'TITAN', radius: 10, distance: 130, color: 0xdeb887, speed: 0.013, hasRings: true },
                { name: 'HYPERION', radius: 6, distance: 200, color: 0x8a2be2, speed: 0.009 },
                { name: 'PROMETHEUS', radius: 12, distance: 300, color: 0xffe4e1, speed: 0.006 },
                { name: 'CHRONOS', radius: 18, distance: 420, color: 0x4682b4, speed: 0.004, hasRings: true },
                { name: 'ECHO', radius: 8, distance: 520, color: 0x00ced1, speed: 0.002 }
            ];

            // Create planets
            planets.length = 0;
            orbitLines.length = 0;
            scene.children = scene.children.filter(obj => obj.userData.type !== 'orbitLine');
            labelsContainer.innerHTML = '';

            planetsData.forEach(planetData => {
                const geometry = new THREE.SphereGeometry(planetData.radius, 32, 32);
                const material = new THREE.MeshPhongMaterial({
                    color: planetData.color,
                    shininess: 18,
                    specular: 0x222244
                });
                const planet = new THREE.Mesh(geometry, material);

                planet.position.x = planetData.distance;
                scene.add(planet);

                planets.push({
                    mesh: planet,
                    data: planetData,
                    angle: Math.random() * Math.PI * 2
                });

                // Create 3D orbit line
                const segments = 128;
                const orbitGeometry = new THREE.BufferGeometry();
                const orbitVertices = [];
                for (let i = 0; i <= segments; i++) {
                    const theta = (i / segments) * Math.PI * 2;
                    orbitVertices.push(
                        Math.cos(theta) * planetData.distance, 0, Math.sin(theta) * planetData.distance
                    );
                }
                orbitGeometry.setAttribute('position', new THREE.Float32BufferAttribute(orbitVertices, 3));
                const orbitMaterial = new THREE.LineBasicMaterial({ color: planetData.color, opacity: 0.35, transparent: true });
                const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
                orbitLine.userData.type = 'orbitLine';
                scene.add(orbitLine);
                orbitLines.push(orbitLine);

                // Create planet label
                const label = document.createElement('div');
                label.className = 'celestial-label';
                label.textContent = planetData.name;
                label.id = `${planetData.name.toLowerCase()}-label`;
                labelsContainer.appendChild(label);

                // Add rings
                if (planetData.hasRings) {
                    const ringGeometry = new THREE.RingGeometry(planetData.radius + 4, planetData.radius + 10, 64);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: planetData.color,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.5
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 3;
                    planet.add(ring);
                }
            });

            // Create black hole at edge of system (closer and more visible)
            blackHole = createBlackHole(350, 60, 350);

            // Add sun label
            const sunLabel = document.createElement('div');
            sunLabel.className = 'celestial-label';
            sunLabel.textContent = 'MILKY WAY SUN';
            sunLabel.id = 'sun-label';
            labelsContainer.appendChild(sunLabel);

            // --- Add comets ---
            createComets('milkyway');
        }
        
        // Initialize solar system
        function initSolarSystem() {
            // Clear previous objects
            scene.children = [];
            scene.add(stars);

            // Create sun
            const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                emissive: 0xffff33,
                emissiveIntensity: 2
            });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            scene.add(sun);

            // Sun light
            const sunLight = new THREE.PointLight(0xffffff, 1.5, 1000);
            sunLight.position.copy(sun.position);
            scene.add(sunLight);

            // Sun glow
            const sunGlowGeometry = new THREE.SphereGeometry(12, 32, 32);
            const sunGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
            sun.add(sunGlow);

            // Planet data for solar system
            const planetsData = [
                { name: 'MERCURY', radius: 3, distance: 50, color: 0x8a8a8a, speed: 0.02 },
                { name: 'VENUS', radius: 4.5, distance: 80, color: 0xe39e1c, speed: 0.015 },
                { name: 'EARTH', radius: 5, distance: 120, color: 0x1e90ff, speed: 0.01 },
                { name: 'MARS', radius: 3.8, distance: 180, color: 0xff4500, speed: 0.008 },
                { name: 'JUPITER', radius: 14, distance: 300, color: 0xd4a373, speed: 0.004 },
                { name: 'SATURN', radius: 12, distance: 400, color: 0xe6dba0, speed: 0.003, hasRings: true },
                { name: 'URANUS', radius: 8, distance: 500, color: 0x7de3f4, speed: 0.002 },
                { name: 'NEPTUNE', radius: 7.8, distance: 600, color: 0x4c6ef5, speed: 0.001 }
            ];

            // Create planets
            planets.length = 0;
            orbitLines.length = 0;
            // Remove previous orbit lines
            scene.children = scene.children.filter(obj => obj.userData.type !== 'orbitLine');
            labelsContainer.innerHTML = '';

            planetsData.forEach(planetData => {
                const geometry = new THREE.SphereGeometry(planetData.radius, 32, 32);
                const material = new THREE.MeshPhongMaterial({
                    color: planetData.color,
                    shininess: 10,
                    specular: 0x111111
                });
                const planet = new THREE.Mesh(geometry, material);

                planet.position.x = planetData.distance;
                scene.add(planet);

                planets.push({
                    mesh: planet,
                    data: planetData,
                    angle: Math.random() * Math.PI * 2
                });

                // Create 3D orbit line
                const segments = 128;
                const orbitGeometry = new THREE.BufferGeometry();
                const orbitVertices = [];
                for (let i = 0; i <= segments; i++) {
                    const theta = (i / segments) * Math.PI * 2;
                    orbitVertices.push(
                        Math.cos(theta) * planetData.distance, 0, Math.sin(theta) * planetData.distance
                    );
                }
                orbitGeometry.setAttribute('position', new THREE.Float32BufferAttribute(orbitVertices, 3));
                const orbitMaterial = new THREE.LineBasicMaterial({ color: 0x64b4ff, opacity: 0.4, transparent: true });
                const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
                orbitLine.userData.type = 'orbitLine';
                scene.add(orbitLine);
                orbitLines.push(orbitLine);

                // Create planet label
                const label = document.createElement('div');
                label.className = 'celestial-label';
                label.textContent = planetData.name;
                label.id = `${planetData.name.toLowerCase()}-label`;
                labelsContainer.appendChild(label);

                // Add ring for Saturn
                if (planetData.hasRings) {
                    const ringGeometry = new THREE.RingGeometry(planetData.radius + 3, planetData.radius + 8, 64);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: 0xf0e68c,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.7
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 3;
                    planet.add(ring);
                }
            });

            // Create black hole at edge of system (closer and more visible)
            blackHole = createBlackHole(300, 50, -400);

            // Add sun label
            const sunLabel = document.createElement('div');
            sunLabel.className = 'celestial-label';
            sunLabel.textContent = 'SUN';
            sunLabel.id = 'sun-label';
            labelsContainer.appendChild(sunLabel);

            // --- Add comets ---
            createComets('solar');
        }
        
        // Initialize alien system
        function initAlienSystem() {
            // Clear previous objects
            scene.children = [];
            scene.add(stars);

            // Create exotic sun
            const sunGeometry = new THREE.SphereGeometry(12, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xff00ff,
                emissive: 0xff33ff,
                emissiveIntensity: 3
            });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            scene.add(sun);

            // Sun light
            const sunLight = new THREE.PointLight(0xff00ff, 2, 1200);
            sunLight.position.copy(sun.position);
            scene.add(sunLight);

            // Sun glow
            const sunGlowGeometry = new THREE.SphereGeometry(15, 32, 32);
            const sunGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff00aa,
                transparent: true,
                opacity: 0.4,
                side: THREE.BackSide
            });
            const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
            sun.add(sunGlow);

            // Planet data for alien system
            const planetsData = [
                { name: 'XERON', radius: 6, distance: 60, color: 0xaa66ff, speed: 0.025 },
                { name: 'ZYLON', radius: 8, distance: 100, color: 0x66ffaa, speed: 0.018 },
                { name: 'QUAZAR', radius: 12, distance: 160, color: 0xff66aa, speed: 0.012 },
                { name: 'ORBIS', radius: 20, distance: 250, color: 0xaaff66, speed: 0.008, hasRings: true },
                { name: 'NEBULA', radius: 16, distance: 350, color: 0x66aaff, speed: 0.005, hasRings: true },
                { name: 'CRYSTAL', radius: 10, distance: 450, color: 0x88ff88, speed: 0.003 }
            ];

            // Create planets
            planets.length = 0;
            orbitLines.length = 0;
            scene.children = scene.children.filter(obj => obj.userData.type !== 'orbitLine');
            labelsContainer.innerHTML = '';

            planetsData.forEach(planetData => {
                const geometry = new THREE.SphereGeometry(planetData.radius, 32, 32);
                const material = new THREE.MeshPhongMaterial({
                    color: planetData.color,
                    shininess: 20,
                    specular: 0x222222
                });
                const planet = new THREE.Mesh(geometry, material);

                planet.position.x = planetData.distance;
                scene.add(planet);

                planets.push({
                    mesh: planet,
                    data: planetData,
                    angle: Math.random() * Math.PI * 2
                });

                // Create 3D orbit line
                const segments = 128;
                const orbitGeometry = new THREE.BufferGeometry();
                const orbitVertices = [];
                for (let i = 0; i <= segments; i++) {
                    const theta = (i / segments) * Math.PI * 2;
                    orbitVertices.push(
                        Math.cos(theta) * planetData.distance, 0, Math.sin(theta) * planetData.distance
                    );
                }
                orbitGeometry.setAttribute('position', new THREE.Float32BufferAttribute(orbitVertices, 3));
                const orbitMaterial = new THREE.LineBasicMaterial({ color: planetData.color, opacity: 0.4, transparent: true });
                const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
                orbitLine.userData.type = 'orbitLine';
                scene.add(orbitLine);
                orbitLines.push(orbitLine);

                // Create planet label
                const label = document.createElement('div');
                label.className = 'celestial-label';
                label.textContent = planetData.name;
                label.id = `${planetData.name.toLowerCase()}-label`;
                labelsContainer.appendChild(label);

                // Add rings
                if (planetData.hasRings) {
                    const ringGeometry = new THREE.RingGeometry(planetData.radius + 4, planetData.radius + 12, 64);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: planetData.color,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.6
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 3;
                    planet.add(ring);
                }
            });

            // Create black hole at edge of system (closer and more visible)
            blackHole = createBlackHole(-350, 80, 300);

            // Add sun label
            const sunLabel = document.createElement('div');
            sunLabel.className = 'celestial-label';
            sunLabel.textContent = 'NOVA PRIME';
            sunLabel.id = 'sun-label';
            labelsContainer.appendChild(sunLabel);

            // --- Add comets ---
            createComets('alien');
        }
        // Create comets for the current system
        function createComets(system) {
            // Remove previous comets
            comets.forEach(c => scene.remove(c.mesh));
            comets.length = 0;

            // Define comet data for each system
            let cometData = [];
            if (system === 'solar') {
                cometData = [
                    { a: 350, b: 80, speed: 0.006, color: 0xffffff, tailColor: 0x99e6ff, size: 2, angle: Math.random() * Math.PI * 2 },
                    { a: 500, b: 120, speed: 0.004, color: 0xfff6e6, tailColor: 0xffeedd, size: 2.5, angle: Math.random() * Math.PI * 2 },
                    { a: 250, b: 60, speed: 0.008, color: 0xbbeeff, tailColor: 0x66ccff, size: 1.5, angle: Math.random() * Math.PI * 2 }
                ];
            } else if (system === 'alien') {
                cometData = [
                    { a: 300, b: 100, speed: 0.007, color: 0xffe6ff, tailColor: 0xff99ff, size: 2.2, angle: Math.random() * Math.PI * 2 },
                    { a: 420, b: 80, speed: 0.005, color: 0xccffcc, tailColor: 0x99ffcc, size: 2.8, angle: Math.random() * Math.PI * 2 }
                ];
            } else if (system === 'milkyway') {
                cometData = [
                    { a: 380, b: 120, speed: 0.005, color: 0xf0f8ff, tailColor: 0xadd8e6, size: 2.3, angle: Math.random() * Math.PI * 2 },
                    { a: 480, b: 160, speed: 0.003, color: 0xe6e6fa, tailColor: 0xdda0dd, size: 2.7, angle: Math.random() * Math.PI * 2 }
                ];
            }

            cometData.forEach(data => {
                // Comet head
                const geometry = new THREE.SphereGeometry(data.size, 16, 16);
                const material = new THREE.MeshBasicMaterial({ color: data.color, emissive: data.color, emissiveIntensity: 1.5 });
                const mesh = new THREE.Mesh(geometry, material);

                // Comet tail (glowing trail)
                const tailLength = 32;
                const tailGeometry = new THREE.BufferGeometry();
                const tailVertices = new Float32Array((tailLength + 1) * 3);
                tailGeometry.setAttribute('position', new THREE.BufferAttribute(tailVertices, 3));
                const tailMaterial = new THREE.LineBasicMaterial({ color: data.tailColor, transparent: true, opacity: 0.7 });
                const tail = new THREE.Line(tailGeometry, tailMaterial);
                mesh.add(tail);

                mesh.userData = { a: data.a, b: data.b, speed: data.speed, angle: data.angle, tail, tailVertices, tailLength };
                scene.add(mesh);
                comets.push({ mesh, data });
            });
        }
        
        // Create black hole (now more visible and closer)
        function createBlackHole(x, y, z) {
            // Event horizon
            const bhGeometry = new THREE.SphereGeometry(20, 64, 64); // Larger size
            const bhMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x000000,
                emissive: 0x660066, // More visible glow
                emissiveIntensity: 1.2
            });
            const bh = new THREE.Mesh(bhGeometry, bhMaterial);
            bh.position.set(x, y, z);
            scene.add(bh);
            
            // Accretion disk (larger and more visible)
            const diskGeometry = new THREE.RingGeometry(21, 40, 64);
            const diskMaterial = new THREE.MeshBasicMaterial({
                color: 0xff00ff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9, // More opaque
                blending: THREE.AdditiveBlending
            });
            const disk = new THREE.Mesh(diskGeometry, diskMaterial);
            disk.rotation.x = Math.PI / 2;
            bh.add(disk);
            
            // Gravitational lensing effect
            const lensingGeometry = new THREE.RingGeometry(20, 30, 64);
            const lensingMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending
            });
            const lensing = new THREE.Mesh(lensingGeometry, lensingMaterial);
            lensing.rotation.x = Math.PI / 2;
            bh.add(lensing);
            
            // Black hole label
            const bhLabel = document.createElement('div');
            bhLabel.className = 'black-hole-label';
            bhLabel.textContent = 'BLACK HOLE (CLICK TO TRAVEL)';
            bhLabel.id = 'black-hole-label';
            labelsContainer.appendChild(bhLabel);
            
            // Make black hole clickable
            bh.userData = { isBlackHole: true };
            
            return bh;
        }
        
        // Initialize the solar system
        initSolarSystem();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // UI Controls
        document.getElementById('reset-btn').addEventListener('click', () => {
            camera.position.set(0, 50, 150);
            controls.reset();
        });
        
        document.getElementById('zoom-out-btn').addEventListener('click', () => {
            controls.dollyOut(2); // Increase value for a more noticeable zoom out
            controls.update();
        });
        
        document.getElementById('toggle-labels-btn').addEventListener('click', () => {
            labelsVisible = !labelsVisible;
            updateLabelsVisibility();
        });
        
        document.getElementById('toggle-orbits-btn').addEventListener('click', () => {
            orbitsVisible = !orbitsVisible;
            orbitLines.forEach(line => line.visible = orbitsVisible);
        });
        
        document.getElementById('warp-btn').addEventListener('click', () => {
            if (blackHole) {
                // Animate camera to black hole
                const startPos = camera.position.clone();
                const endPos = blackHole.position.clone();
                const duration = 1500;
                const startTime = Date.now();
                
                function animateWarp() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(1, elapsed / duration);
                    
                    camera.position.lerpVectors(startPos, endPos, easeInOutCubic(progress));
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateWarp);
                    } else {
                        travelThroughBlackHole();
                    }
                }
                
                animateWarp();
            }
        });
        
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        // Update labels visibility
        function updateLabelsVisibility() {
            const labels = document.querySelectorAll('.celestial-label');
            labels.forEach(label => {
                label.style.display = labelsVisible ? 'block' : 'none';
            });
        }
        
        // Function to update labels with distance-based fading
        function updateLabels() {
            const labelDistanceThreshold = 400;
            
            // Update sun label
            if (sun) {
                const sunScreenPos = new THREE.Vector3().copy(sun.position).project(camera);
                const sunX = (sunScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                const sunY = (-sunScreenPos.y * 0.5 + 0.5) * window.innerHeight;
                
                const sunLabel = document.getElementById('sun-label');
                if (sunLabel) {
                    sunLabel.style.left = `${sunX}px`;
                    sunLabel.style.top = `${sunY}px`;
                    
                    const sunDistance = camera.position.distanceTo(sun.position);
                    if (labelsVisible) {
                        sunLabel.style.opacity = Math.min(1, 1 - (sunDistance / labelDistanceThreshold));
                    }
                }
            }
            
            // Update planet labels
            planets.forEach(planet => {
                const planetScreenPos = new THREE.Vector3().copy(planet.mesh.position).project(camera);
                const x = (planetScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-planetScreenPos.y * 0.5 + 0.5) * window.innerHeight;
                
                const label = document.getElementById(`${planet.data.name.toLowerCase()}-label`);
                if (label) {
                    label.style.left = `${x}px`;
                    label.style.top = `${y}px`;
                    
                    const planetDistance = camera.position.distanceTo(planet.mesh.position);
                    if (labelsVisible) {
                        label.style.opacity = Math.min(1, 1 - (planetDistance / labelDistanceThreshold));
                    }
                }
            });
            
            // Update black hole label and portal
            if (blackHole) {
                const bhScreenPos = new THREE.Vector3().copy(blackHole.position).project(camera);
                const bhX = (bhScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                const bhY = (-bhScreenPos.y * 0.5 + 0.5) * window.innerHeight;
                
                const bhLabel = document.getElementById('black-hole-label');
                if (bhLabel) {
                    bhLabel.style.left = `${bhX}px`;
                    bhLabel.style.top = `${bhY}px`;
                    
                    const bhDistance = camera.position.distanceTo(blackHole.position);
                    if (labelsVisible) {
                        bhLabel.style.opacity = Math.min(1, 1 - (bhDistance / (labelDistanceThreshold * 1.5)));
                    }
                }
                
                // Update portal position
                blackHolePortal.style.left = `${bhX}px`;
                blackHolePortal.style.top = `${bhY}px`;
                blackHolePortal.style.display = 'block';
                blackHolePortal.style.width = '100px';
                blackHolePortal.style.height = '100px';
            }
        }
        
        // Travel through black hole to other system
        function travelThroughBlackHole() {
            blackHolePortal.style.display = 'none';
            
            // Animate warp effect
            const startTime = Date.now();
            const duration = 2000;

            function animateWarp() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(1, elapsed / duration);

                // Distortion effects
                camera.fov = 60 + (progress * 40);
                camera.updateProjectionMatrix();
                camera.rotation.z = progress * Math.PI * 4;

                if (progress < 1) {
                    requestAnimationFrame(animateWarp);
                } else {
                    // Cycle through all three systems
                    if (currentSystem === SOLAR_SYSTEM) {
                        currentSystem = ALIEN_SYSTEM;
                        initAlienSystem();
                    } else if (currentSystem === ALIEN_SYSTEM) {
                        currentSystem = MILKY_WAY_SYSTEM;
                        initMilkyWaySystem();
                    } else {
                        currentSystem = SOLAR_SYSTEM;
                        initSolarSystem();
                    }

                    // Reset camera with cool effect
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                    camera.rotation.set(0, 0, 0);
                    camera.position.set(0, 50, 150);
                    controls.reset();
                }
            }

            animateWarp();
        }
        
        // Handle clicks on objects
        renderer.domElement.addEventListener('click', (event) => {
            // Calculate mouse position in normalized device coordinates
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Set up raycaster
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Check for intersections
            const intersects = raycaster.intersectObjects(scene.children);
            
            if (intersects.length > 0) {
                const object = intersects[0].object;
                
                // Check if clicked on black hole
                if (object.userData.isBlackHole) {
                    travelThroughBlackHole();
                }
            }
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Rotate sun with pulsing glow
            if (sun) {
                sun.rotation.y += 0.005;
                if (sun.children.length > 0) {
                    const glow = sun.children[0];
                    glow.scale.setScalar(1 + Math.sin(Date.now() * 0.001) * 0.05);
                }
            }

            // Update planets
            planets.forEach(planet => {
                planet.angle += planet.data.speed;
                planet.mesh.position.x = Math.cos(planet.angle) * planet.data.distance;
                planet.mesh.position.z = Math.sin(planet.angle) * planet.data.distance;
                planet.mesh.rotation.y += 0.01;

                // Rotate rings
                if (planet.data.hasRings && planet.mesh.children.length > 0) {
                    planet.mesh.children[0].rotation.y += 0.005;
                }
            });

            // --- Animate comets ---
            comets.forEach(comet => {
                const u = comet.mesh.userData;
                u.angle += u.speed;
                // Elliptical orbit
                comet.mesh.position.x = Math.cos(u.angle) * u.a;
                comet.mesh.position.z = Math.sin(u.angle) * u.b;
                comet.mesh.position.y = Math.sin(u.angle * 2) * 10;

                // Animate tail
                const tail = u.tail;
                const tailVertices = u.tailVertices;
                for (let i = 0; i <= u.tailLength; i++) {
                    const t = u.angle - i * 0.07;
                    tailVertices[i * 3] = Math.cos(t) * u.a;
                    tailVertices[i * 3 + 1] = Math.sin(t * 2) * 10;
                    tailVertices[i * 3 + 2] = Math.sin(t) * u.b;
                }
                tail.geometry.attributes.position.needsUpdate = true;
            });

            // Update black hole effects
            if (blackHole && blackHole.children.length >= 2) {
                blackHole.children[0].rotation.z += 0.01; // Disk rotation
                blackHole.children[1].rotation.z -= 0.02; // Lensing rotation

                // Pulsing lensing effect
                const scale = 1 + Math.sin(Date.now() * 0.002) * 0.2;
                blackHole.children[1].scale.set(scale, scale, 1);
            }

            // (No need to update orbit paths, handled by Three.js)

            // Update labels
            updateLabels();

            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>